warning: LF will be replaced by CRLF in Trial division.layout.
The file will have its original line endings in your working directory.
[1mdiff --git a/Trial division.layout b/Trial division.layout[m
[1mindex 2b499b2..dc6f4cd 100644[m
[1m--- a/Trial division.layout[m	
[1m+++ b/Trial division.layout[m	
[36m@@ -4,7 +4,7 @@[m
 	<ActiveTarget name="Debug" />[m
 	<File name="main.cpp" open="1" top="1" tabpos="1" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">[m
 		<Cursor>[m
[31m-			<Cursor1 position="354" topLine="49" />[m
[32m+[m			[32m<Cursor1 position="1986" topLine="0" />[m
 		</Cursor>[m
 	</File>[m
 </CodeBlocks_layout_file>[m
[1mdiff --git a/main.cpp b/main.cpp[m
[1mindex bfc6f6c..28935dd 100644[m
[1m--- a/main.cpp[m
[1m+++ b/main.cpp[m
[36m@@ -11,7 +11,7 @@[m [mvoid find_divider (int N, int *prime_numbers, bool *result, int i)[m
         result[N] = true;[m
         while(prime_numbers[i])[m
         {[m
[31m-            if (!(N % prime_numbers[i]))                          //если это делитель[m
[32m+[m[32m            if (!(N % prime_numbers[i]))                          //if it is divider[m
             {[m
                 int divider = N / prime_numbers[i];[m
                 find_divider(divider, prime_numbers, result, i);[m
[36m@@ -27,35 +27,35 @@[m [mvoid Eratrosphen (int N)[m
     for (int i = 0; i <= N; i++)[m
         result[i] = false;[m
     result[1] = true;[m
[31m-    if (!(N % 2))                //если число парное[m
[32m+[m[32m    if (!(N % 2))                //if the number is even[m
     {[m
         prime_numbers[iter] = 2;[m
         result[2] = true;[m
         iter++;[m
     }[m
     for (int i = 3; i <= sqrtN; i += 2)[m
[31m-        arr[i] = i;                              //простым делителем может быть только нпарное число, кроме 2[m
[32m+[m[32m        arr[i] = i;                              //prime divider can be only odd number, except 2[m
     for (int i = 3; i <= sqrtN; i += 2)[m
     {[m
         if (arr[i])[m
             {[m
[31m-               if (!(N % arr[i])) {                //если это делитель[m
[32m+[m[32m               if (!(N % arr[i])) {                //if it is divider[m
                     prime_numbers[iter] = arr[i];[m
                     result[arr[i]] = true;[m
                     iter++ ;[m
                }[m
[31m-                for (int j = i * i; j <= sqrtN; j += 2 * i){   //если найден простой делитель, все остальные делители[m
[31m-                     arr[j] = 0;                               //что он образует, удаляем[m
[32m+[m[32m                for (int j = i * i; j <= sqrtN; j += 2 * i){   //if the prime number if found[m
[32m+[m[32m                     arr[j] = 0;                               //delete all other dividers, that it creates[m
                      }[m
             }[m
     }[m
[31m-    if (!iter){                                                //проверка на ввод простого числа[m
[32m+[m[32m    if (!iter){                                                //check if input is prime number[m
         cout << "This is prime number" << endl;[m
         return;[m
     }[m
[31m-    prime_numbers[iter] = 0;                                   //остановка рекурсии, когда простой делитель равен 0[m
[32m+[m[32m    prime_numbers[iter] = 0;                                   //the recursion stops when the prime number equals to 0[m
     find_divider(N, prime_numbers, result, 0);[m
[31m-    for (int i = 0; i <= N; i++)                               //вывод[m
[32m+[m[32m    for (int i = 0; i <= N; i++)                               //output[m
         if (result[i]) cout << i << " ";[m
 }[m
 [m
